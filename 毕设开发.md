# 系统功能设计规划：

1.系统先行功能：

![image-20230120112343900](C:\Users\WEZARD\AppData\Roaming\Typora\typora-user-images\image-20230120112343900.png)





2.前端页面设计：

![image-20230120112410278](C:\Users\WEZARD\AppData\Roaming\Typora\typora-user-images\image-20230120112410278.png)





1. 页面总体概览：

   分为上中下三栏

   ![image-20230120112718590](C:\Users\WEZARD\AppData\Roaming\Typora\typora-user-images\image-20230120112718590.png)

   ![image-20230120113218028](C:\Users\WEZARD\AppData\Roaming\Typora\typora-user-images\image-20230120113218028.png)

   ![image-20230120113603071](C:\Users\WEZARD\AppData\Roaming\Typora\typora-user-images\image-20230120113603071.png)

![image-20230120151906237](C:\Users\WEZARD\AppData\Roaming\Typora\typora-user-images\image-20230120151906237.png). q





# 前端开发

### 用户前端页面开发：

1.20:

嘗試前後端交互：

- 遇到問題：前後端交互跨域問題：

  解決方案：

  https://blog.csdn.net/huhui806/article/details/115941806

  但仍然不能解决 springboot 内部出现的问题，因此只有降级一路降到 2.2.0

  



1.21：

进行前端页面制作：

确定首页：规划3，游客可浏览。



**难点:**

- <u>移动端和PC端尺寸问题，</u>通过@media 以及判断当前尺寸解决

- <u>走马灯的导航条显示在中间</u>，通过设置总页面大小解决

- <u>无限滑动加载的难题</u>

- <u>滑动 header 跟着滑动的问题</u>：解决方案：

  ```
  https://blog.csdn.net/hotqin888/article/details/88755918
  ```

  

- 收藏以及取消收藏的难题：

  ```
  https://blog.csdn.net/GuiBing_haonan/article/details/126747391?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8-126747391-blog-116158559.pc_relevant_aa&spm=1001.2101.3001.4242.5&utm_relevant_index=11
  ```

- <u>分页难题</u>：前端分页与后端分页



1.25 

**难点**

- 路由跳转问题，一点击就整个跳到别的页面而不是嵌套在里面

解决：采用插槽的方式直接组件化开发。



登录页面设计：https://blog.csdn.net/weixin_44948981/article/details/123474222

引入工具







1.26 电影详情页面



安装图标库：

```
https://www.likecs.com/show-306168339.html#sc=300
```

此图标库不可用，因此更换，阿里图标库；

https://blog.csdn.net/qq_43080548/article/details/123922448





关于二级评论以及输入框的预想实施方案：

https://blog.csdn.net/weixin_46015333/article/details/127035370



一些页面跳转的参考方式：

https://ipkd.cn/webs_2677.html



1.30 个人中心：

​	

### 管理员后台页面

1.31 后台开始开发：

界面设计：

![image-20230120112343900](https://img.zcool.cn/community/0160856102184f11013eaf700a3394.png?x-oss-process=image/auto-orient,1/resize,m_lfit,w_1280,limit_1/sharpen,100)





![image-20230120112343900](https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2&hs=0&pn=1&spn=0&di=7169026086108397569&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&ie=utf-8&oe=utf-8&cl=2&lm=-1&cs=3837124218%2C3402063749&os=207926243%2C3284103369&simid=3837124218%2C3402063749&adpicid=0&lpn=0&ln=30&fr=ala&fm=&sme=&cg=&bdtype=0&oriquery=%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2&objurl=https%3A%2F%2Ftuchuang.shangzhuti.com%2Fimg%2F2020%2F12%2F106-3.png&fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Br42551_z%26e3BvgAzdH3F98bn_z%26e3Bip4s&gsm=&islist=&querylist=&dyTabStr=MCwzLDEsNCw2LDUsMiw3LDgsOQ%3D%3D)





### 注意点！

需要下载 echarts 做图形分析数据使用！

https://echarts.apache.org/handbook/zh/basics/download/

```
npm install echarts
```





2.1 完成后台页面





------

#  数据库模块设计：

2.2



**数据库设计原则：**

————————————————

```
部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。
例子：学， 学号属性取值是唯一的，在R关系中，姓名）；所以姓名部分函数依赖与（学号，身份证号）；
完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。
例子：学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；

传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。
例子：在关系R(学号 ,宿舍, 费用)中，(学号)->(宿舍),宿舍！=学号，(宿舍)->(费用),费用!=宿舍，所以符合传递函数的要求；
————————————————

第一范式：原子属性，数据不可再分割

第二范式：必须有主键 ；没有包含在主键中的列必须 完全依赖 于主键，而不能只依赖于主键的一部分。
例子：当数据表中是联合主键，但是有的列只依赖联合主键中的一个或一部分属性组成的联合主键，此时需要拆表才能复合第二范式。

第三范式：每一个非主属性都不传递依赖于该范式的候选键（只依赖于主键）
不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
例子：Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)，当员工表中emp_id能够唯一确定员工员工信息，
但是dept_name可由dept_id唯一确定，此时，该表不符合第三范式，此时可以删除除了dept_id之外的其他部门信息，把所有部门信息单独建立一张部门表。
```





#### 数据库主要字段设计：

##### 电影信息表：（movie_detail）

| id             | bigInt       | /                |
| -------------- | ------------ | ---------------- |
| name           | varchar(64)  | 电影名           |
| director       | varchar(64)  | 导演             |
| staring        | varchar(64)  | 电影主演         |
| country        | varchar(32)  | 国家和地区       |
| languague      | varchar(32)  | 语言             |
| release_date   | int          | 发行年份         |
| post           | varchar(255) | 海报             |
| writer         | varchar(32)  | 编剧             |
| douban_data_id | varchar(32)  | 豆瓣id           |
| length         | int          | 电影时长（分钟） |
| summary        | longtext     | 简介             |
| genres         | varchar(256) | 类型             |
|                |              |                  |
|                |              |                  |



##### *电影类别表：（types）

| id   | bigInt      | /      |
| ---- | ----------- | ------ |
| name | varchar(64) | 类别名 |
|      |             |        |
|      |             |        |
|      |             |        |



##### *电影-类别对照表：（movie_types）

| id       | bigInt | /                    |
| -------- | ------ | -------------------- |
| movie_id | bigInt | 对应的电影id（外键） |
| type_id  | bigInt | 对应的类别id（外键） |



##### 电影详情表（互动信息）：（movie）

| id          | bigInt   | /              |
| ----------- | -------- | -------------- |
| movie_id    | bigInt   | 电影id（外键） |
| comment_num | int      | 评论数量       |
| socre       | double   | 分数           |
| ratings_num | int      | 评分人数       |
| collect_num | int      | 收藏数         |
| put_on_date | datetime | 上架系统时间   |



##### 影评表：（movie_comments):

| id           | bigInt   | /               |
| ------------ | -------- | --------------- |
| movie_id     | bigInt   | 电影id（外键）  |
| user_id      | bigInt   | 用户Id （外键） |
| content      | longtext | 详细评论        |
| likes        | int      | 点赞数          |
| comments_num | Int      | 评论数          |
| comment_time | datetime | 评论时间        |
|              |          |                 |
|              |          |                 |



##### 评论表：（comments）：

| id           | bigInt   | /              |
| ------------ | -------- | -------------- |
| movie_id     | bigInt   | 电影id（外键） |
| mc_id        | bigInt   | 影评id（外键） |
| parent_id    | bigInt   | 上级评论id     |
| user_id      | bigInt   | 用户id（外键） |
| content      | longtext | 内容           |
| comment_time | datetime | 评论时间       |
|              |          |                |



##### 用户表：（user）：

| id          | bigInt       | /                          |
| ----------- | ------------ | -------------------------- |
| username    | varchar(64)  | 用户名                     |
| account     | varchar(64)  | 登录账号                   |
| password    | varchar(64)  | 密码                       |
| avatar      | varchar(256) | 头像                       |
| create_time | datetime     | 创建时间                   |
|             |              |                            |
|             |              |                            |
| status      | int          | 账号状态（正常/禁言/封禁） |
| salt        | varchar(64)  | 用户盐（加密用）           |
| login_time  | datetime     | 用户上次登录时间           |
| label       | varchar(64)  | 用户喜欢的类型标签         |

用户登录时间：若登录时间超过14天则为非活跃用户，不推荐电影


##### 个人评分表：（user_scored）：

| id       | bigInt | /              |
| -------- | ------ | -------------- |
| user_id  | bigInt | 用户id（外键） |
| movie_id | bigInt | 电影id（外键） |
| score    | double | 分数           |
|          |        |                |



##### 推荐表：（recommendation）：

| id       | bigInt | /              |
| -------- | ------ | -------------- |
| user_id  | bigInt | 用户id（外键） |
| movie_id | bigInt | 电影id（外键） |
|          |        |                |
|          |        |                |



##### 排行榜表：（top）：

| id       | bigInt | /                                        |
| -------- | ------ | ---------------------------------------- |
| movie_id | bigInt | 电影id（外键）                           |
| type     | int    | 排行类型,1 最热 ，2 最多评论 ，3最多收藏 |
| rank     | int    | 排位                                     |



##### 用户收藏表 (collections)：

| id           | bigInt   | /              |
| ------------ | -------- | -------------- |
| movie_id     | bigInt   | 电影id（外键） |
| user_id      | bigInt   | 用户id（外键） |
| collect_time | datetime | 收藏时间       |



##### 用户浏览记录表：(history):

| id         | bigInt   | /              |
| ---------- | -------- | -------------- |
| movie_id   | bigInt   | 电影id（外键） |
| user_id    | bigInt   | 用户id（外键） |
| click_time | datetime | 浏览的时间     |



为了使得用户收藏只能一次收藏，防止多次收藏，必须要对movie_id 和 user_id 做唯一性约束：

```sql
ALTER TABLE `zmovie`.`collections` 
ADD UNIQUE INDEX `unique_collections_key`(`movie_id`, `user_id`);
```





#  后端设计：	

2.7

配置好项目，使用 mybaits-plus.



##### 日志配置：

​	利用切面aspect，将方法调用的url、ip、方法以及参数在控制台中通过日志方式打印出来。

```
package com.zz.zmovie.Aspect;

import org.apache.coyote.Request;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;

@Aspect
@Component
public class LogAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());


    @Pointcut("execution(* com.zz.zmovie.Controller.*.*(..))")
    public void log() {
    }

    @Before("log()")
    public void doBefore(JoinPoint joinPoint) {     //切入点切入，调用方法前获取调用信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();

        String url = request.getRequestURI().toString();        //获取需要展示的参数
        String ip = request.getRemoteAddr();
        String classMethod = joinPoint.getSignature().getDeclaringTypeName()+"."+joinPoint.getSignature().getName();
        Object args[] = joinPoint.getArgs();

        RequestLog log = new RequestLog(url,ip,classMethod,args);      //赋值到内部类中更好的展示
        System.out.println(log);
    }

    private  class RequestLog{
        private String url;
        private String ip;
        private String classMethod;
        private Object[] args;

        public RequestLog(String url, String ip, String classMethod, Object[] args) {
            this.url = url;
            this.ip = ip;
            this.classMethod = classMethod;
            this.args = args;
        }

        @Override
        public String toString() {
            return "RequestLog{" +
                    "url='" + url + '\'' +
                    ", ip='" + ip + '\'' +
                    ", classMethod='" + classMethod + '\'' +
                    ", args=" + Arrays.toString(args) +
                    '}';
        }
    }
}

```





mybatis-plus测试：

<u>遇到坑！：</u>

```
Invalid bound statement (not found)
```



解决方法：

```java
package com.zz.zmovie.mapper;

//import com.baomidou.mybatisplus.mapper.BaseMapper;		//这个是错误的！！！
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.zz.zmovie.po.Test;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface TestMapper extends BaseMapper<Test> {
}
```



、

2.8:

##### 配置 DRUID 数据库连接池：



​	**Druid 访问管理页面**

```
http://localhost:8081/druid/index.html
```

```yml上进行配置
spring:
  datasource:
    driver-class-name:  com.mysql.jdbc.Driver
    url : jdbc:mysql://localhost:3306/zmovie?useUnicode=true&characterEncoding=utf8&useSSL=false
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource

    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
    filters: stat, log4j, wall
    maxPoolPreparedStatementPerConnectionSize: 20
    use-global-data-source-stat: true
    connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
```



同时还要创建一个config文件来过滤所有的数据库请求





##### 配置 Redis 缓存数据库：



- 引入 jedis

- 创建 jedis 线程池：

  ```java
  package com.zz.zmovie.redis;
  
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.context.annotation.Bean;
  import org.springframework.stereotype.Service;
  import redis.clients.jedis.JedisPool;
  import redis.clients.jedis.JedisPoolConfig;
  
  @Service
  public class RedisPoolFactory {
  
      @Autowired
      RedisConfig redisConfig;
  
      //	初始化，并且添加到bean，这样子就能通过注解的方式注入线程池
      @Bean
      public JedisPool JedisPoolFactory() {
          //从 redisconfig 中获取值设置 线程池
          JedisPoolConfig poolConfig = new JedisPoolConfig();
  
  
          poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());		//最大空闲
  
          poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());		///最大连接数
  
          poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000);		//用尽后最大等待时间
  
          JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),
                  redisConfig.getTimeout()*1000, redisConfig.getPassword(), 1);       //1号数据库
  
          return jp;
      }
  
  }
  
  ```



##### 自定义异常类以及自定义状态码：

构成：

- 状态码枚举类

- 真正返回信息类

- 自定义的一个异常类，满足自己所需异常处理

- 异常处理类，返回数据 到前端按情况进行相应处理

  

  ```java
  package com.zz.zmovie.utils;
  
  import lombok.Getter;
  
  @Getter
  public enum ResultStatus {
      SUCCESS(100001,"成功"),
      FAILURE(100002,"失败");
  
      private int code;
      private String message;
  
      private ResultStatus(int code, String message) {
          this.code = code;
          this.message = message;
      }
  }
  
  ```

  ```java
  package com.zz.zmovie.utils;
  
  import lombok.Data;
  
  import java.io.Serializable;
  
  //返回结果信息类,封装返回给前端的数据集合。
  @Data
  public class ResultGeekQ<T> implements Serializable {
      private static final long serialVersionUID = 867933019328199779L;
      private T data;     //另外的信息
      int code;           //异常码
      String message;     //异常描述信息
  
      private ResultGeekQ(T data,ResultStatus status, String message) {
          this.data = data;
          this.code = status.getCode();
          this.message = message;
      }
  
      private ResultGeekQ(ResultStatus status, String message) {
          this.code = status.getCode();
          this.message = message;
      }
      private ResultGeekQ(ResultStatus status) {
          this.code = status.getCode();
          this.message = status.getMessage();
      }
  
      //直接返回成功的状态信息
      public static <T> ResultGeekQ<T> build() {
          return new ResultGeekQ(ResultStatus.SUCCESS);
      }
  
      //携带信息的成功状态码，
      public static <T> ResultGeekQ<T> build(String message) {
          return new ResultGeekQ(ResultStatus.SUCCESS, message);
      }
  
      //    失败信息
      public static <T> ResultGeekQ<T> error(ResultStatus status) {
          return new ResultGeekQ<T>(status);
      }
  ```

  ```java
  package com.zz.zmovie.exception;
  
  import com.zz.zmovie.utils.ResultStatus;
  
  //自定义异常类，接受所抛出的异常
  public class GlobleException extends RuntimeException {
  
      private ResultStatus status;
  
      public GlobleException(ResultStatus status){
          super();
          this.status = status;
      }
  
      public ResultStatus getStatus() {
          return status;
      }
  
      public void setStatus(ResultStatus status) {
          this.status = status;
      }
  
  }
  ```

  ```java
  package com.zz.zmovie.exception;
  
  import com.zz.zmovie.utils.ResultGeekQ;
  import com.zz.zmovie.utils.ResultStatus;
  import org.slf4j.Logger;
  import org.slf4j.LoggerFactory;
  import org.springframework.validation.BindException;
  import org.springframework.validation.ObjectError;
  import org.springframework.web.bind.annotation.ControllerAdvice;
  import org.springframework.web.bind.annotation.ExceptionHandler;
  import org.springframework.web.bind.annotation.ResponseBody;
  
  import javax.servlet.http.HttpServletRequest;
  import java.util.List;
  
  //异常捕捉
  @ControllerAdvice
  public class GlobalExceptionHandler {
  
      private static Logger logger =  LoggerFactory.getLogger(GlobalExceptionHandler.class);
  
      /**
       * 拦截抛出的错误，并且根据错误种类、的信息来返回结果信息
       */
      @ExceptionHandler(value=Exception.class)
      @ResponseBody
      public ResultGeekQ<String> exceptionHandler(HttpServletRequest request , Exception e){
  //        例如我们在login过程中，可能会有密码错误，用户名不存在这些错误，一般也都是在service层中进行处理，但是这里我们只是将异常进行抛出，不进行具体的处置。减少了代码的冗余度。
  
          e.printStackTrace();
          if(e instanceof GlobleException){
              //如果是定义好的异常的话 
              GlobleException ex = (GlobleException)e;
              //返回结果信息
              return ResultGeekQ.error(ex.getStatus());
          }else if( e instanceof BindException){
              // 绑定异常
              BindException ex = (BindException) e  ;
              List<ObjectError> errors = ex.getAllErrors();
  
              //参数校检有很多的错误
              ObjectError error = errors.get(0);
              String msg = error.getDefaultMessage();
              /**
               * 打印堆栈信息
               */
              logger.error(String.format(msg, msg));
              return ResultGeekQ.error(ResultStatus.FAILURE);
          }else {
              return ResultGeekQ.error(ResultStatus.FAILURE);
          }
      }
  }
  ```



<font color='orange'>返回的数据形式：</font>

```json
{
    "data": null,
    "code": 100002,
    "message": "失败"
}
```



2.10：

##### 电影数据：

1. ​	用到的数据集从 movieLens 上。

2. ​    从豆瓣爬虫：

   *确定从豆瓣爬虫信息*，将爬虫得到的csv文件导入到MySQL中




2.11:

##### 登录模块设计：

定义好关于登录的状态码，若遇到账号不存在、密码错误等就直接抛出状态码返回到前端进行处理。

单次 MD5 加密就已经足够。



登录时：先在 redis 缓存中寻找是否有缓存记录，无则到数据库中进行寻找。





**<font color='cornflowerblue'>首先先先定义 redis 键的前缀，这样子即使缓存数据多也不会混淆：</font>**



![](C:\Users\WEZARD\Desktop\毕设\无标题.png)



**<font color='cornflowerblue'>再定义 Redis 的 get set 方法等：</font>**



```java

    /**
     * 从 redis 中取出数据
     * @param prefix    数据的键值前缀
     * @param key          数据的键区分部分
     * @param clazz         数据取出来时是字符串格式，需要重新转化为对应的 class 对象
     * @param <T>
     * @return
     */
    public <T> T get(RedisPrefix prefix,String key,Class<T> clazz){
        JedisPool jedisPool = null;
        Jedis jedis = null;
        try {
            jedisPool = redisPoolFactory.JedisPoolFactory();
            jedis= jedisPool.getResource();      //从池子中获取连接

            String realKey = prefix.getPrefix() + "_" + key;        //真正存储到 redis 中的键：

            String res = jedis.get(realKey);
            T t = stringToBean(res,clazz);      //将结果重新转换

            return t;
        } finally {
            jedis.close();
        }
    }

    /**
     * 插入
     * @param redisPrefix
     * @param key
     * @param value
     * @param <T>
     * @return
     */
    public <T> boolean set(RedisPrefix redisPrefix,String key,T value){
        JedisPool jedisPool = null;
        Jedis jedis = null;
        try {
            jedisPool = redisPoolFactory.JedisPoolFactory();
            jedis= jedisPool.getResource();      //从池子中获取连接

            String realKey = redisPrefix.getPrefix() + "_" +key;
            String val = beanToString(value);      //将 各种数据类型转换为 String 类型的 value
            int expireSeconds = redisPrefix.getExpireSeconds();     //过期时间


            if(expireSeconds > 0){
                jedis.setex(realKey,expireSeconds,val);
            }else{
                jedis.set(realKey,val);
            }
            return true;
        } finally {
            jedis.close();
        }

    }

```



设置好token，分别存放在 redis 和 cookie 之中，这样子可以通过拦截器来获取用户的内容，不需要每一次都要传递用户参数。

```java

    public void addToCookie(HttpServletResponse response,String token,User user){
        redisService.set(UserPrefix.userToken,token,user);

        Cookie cookie = new Cookie("token",token);
        cookie.setMaxAge(UserPrefix.userToken.getExpireSeconds());
        cookie.setPath("/");

        response.addCookie(cookie);     //存放到客户端
    }
```





##### 拦截器设置：

<font color='orange'>用作用户单点登录</font>

定义拦截器，这样子，用户登录之后的 token 信息便可以拦截下来，存放到 ThreadLocal 之中，

ThreadLocal 是线程私有变量。

```java
  String token = getCookie(response, request);

        if (!StrUtil.isEmpty(token)) {
            System.out.println(token);
            User user = userService.getByToken(response, token);
            System.out.println(user);
            UserThreadLocal.set(user);
        }

```



这样子，通过ThreadLocal 的 get 方法我们便可以随时随地的取出用户信息。

```

public class UserThreadLocal {

    private static ThreadLocal<User> threadLocal;

    public static void set(User user){
        threadLocal.set(user);          //添加到当前线程之中内存存放。
    }

    public static User get(){
        return threadLocal.get();
    }

    //防止内存泄露
    private static void remove(){
        threadLocal.remove();
    }
}

```



2.14

##### 首页设计：



1. <font color='red'>mybatis-plus 无法进行 limit 语法（分页查询）：</font>

   解决方法：添加配置类：

   ```
   package com.cloudguest.config;
   
   import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
   import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   public class MPconfig {
   
       @Bean
       public MybatisPlusInterceptor mybatisPlusInterceptor(){
           // 1、定义MP拦截器
           MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
           // 2、添加具体的拦截器
           interceptor.addInnerInterceptor(new PaginationInnerInterceptor());
           return interceptor;
       }
   }
   
   ```

   



最热电影设置：

```
首先定义好最热，预存数据库，最热电影，每天维护更新。

查询时，先查询redis，redis没有则查询数据库，并且添加到redis当中去。

redis 存储 list 时，需要将list转换为Json数组，再转换为String进行存储。

这里的转换工具用到了 Hutool
```



##### 收藏：

登录的时候，判断 redis 是否有收藏列表，若无则从数据库中取出并且放置到 redis。





##### 电影详情：

问题：当滚动加载最新电影的时候，一次滚动但是发送好几次请求。

解决方案：https://code84.com/420193.html



关于 vue 传参：https://blog.csdn.net/qq_41890177/article/details/128408868



跳转电影详情的时候，先 vue 路径路由跳转，再由 created()  页面加载前向后端发送请求加载数据





##### 排行榜：

```sql

SELECT
	a.*,
	@rank := @rank + 1 AS rank 
FROM
	( SELECT * FROM movie ORDER BY comment_num DESC ) AS a,
	( SELECT @rank := 0 ) r
```

按照排序值生成排名列的模板。	



将查询到的结果插入到数据库：

```sql
insert into top(movie_id,type,rank)  
SELECT
	a.movie_id,2 as type,
	@rank := @rank + 1 AS rank 
FROM
	( SELECT * FROM movie ORDER BY comment_num DESC ) AS a,
	( SELECT @rank := 0 ) r limit 10;
```







##### 分类：

vue 父组件与子组件传递数据：https://blog.csdn.net/m0_54355172/article/details/127282719

https://blog.csdn.net/qq_44235822/article/details/97659201?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-97659201-blog-115552354.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-97659201-blog-115552354.pc_relevant_recovery_v2&utm_relevant_index=6



上一页与下一页的设计：

首先将 上一页按钮的 cursor 属性设置为  not-allowed，即禁用状态，初始化不能上一页，当下一页点击之后才可将之设为 pointer 可点击。下一页同理。

```vue
首先是方法：
  nextPage(){   //判断当前页面是否第一页，将上一页禁用
        if(this.curPage < this.maxPage){
          this.curPage++;
        }
      },
 lastPage(){
        if(this.curPage > 1 ){
          this.curPage--;
        }
  }
```

再 watch 函数实时监听页码变化：

```vue
  watch:{
       curPage: function (newVal,oldVal) {
         console.log("new:"+newVal);
         console.log(oldVal)
         console.log("max:" +this.maxPage)
         if(newVal >= this.maxPage){
           console.log("ban")
           document.getElementById("nextPage").style.cursor=' not-allowed';   //禁用
           console.log( document.getElementById("nextPage").style.cursor)
           // this.ban("nextPage");
         }
         else if(newVal <= 1){
           document.getElementById("lastPage").style.cursor=' not-allowed';   //禁用
         }else{
           document.getElementById("nextPage").style.cursor='pointer';
           document.getElementById("lastPage").style.cursor='pointer';
         }
       }
    },
```

 



将分类数据发到后台：

https://blog.csdn.net/qq_29339467/article/details/123337467

**注意！get请求不可发送Json 数据，只有post可以**



关于前端调用布局：

*出现的问题：当最后一行数量不足6的时候，将会自动分散对齐*

解决方法：https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&mid=2649091838&idx=1&sn=fa4e1ed1e02d2813633691220c60f52f&chksm=be5bc953892c4045b64fa5a804a1d3676f5894d405f477eed1032dac2ab49e2026b480cedb7d&scene=27



